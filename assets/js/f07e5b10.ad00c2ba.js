"use strict";(self.webpackChunkextention_technologies_docs=self.webpackChunkextention_technologies_docs||[]).push([[7256],{3905:function(e,t,a){a.d(t,{Zo:function(){return d},kt:function(){return h}});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var c=n.createContext({}),l=function(e){var t=n.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},d=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,c=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),p=l(a),h=r,m=p["".concat(c,".").concat(h)]||p[h]||u[h]||i;return a?n.createElement(m,s(s({ref:t},d),{},{components:a})):n.createElement(m,s({ref:t},d))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,s=new Array(i);s[0]=p;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:r,s[1]=o;for(var l=2;l<i;l++)s[l]=a[l];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}p.displayName="MDXCreateElement"},3937:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return o},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return d},default:function(){return p}});var n=a(7462),r=a(3366),i=(a(7294),a(3905)),s=["components"],o={sidebar_position:3},c="Sqlite Database",l={unversionedId:"React Native Starters/Sqlite Database",id:"React Native Starters/Sqlite Database",isDocsHomePage:!1,title:"Sqlite Database",description:"In this guide, we are going to take a look at using SQLite to store and persist data locally in our React Native applications. SQLite is available on nearly all mobile devices. We have to write SQL queries to access it, however, the data returned is in javascript arrays & objects form. We are going to perform CRUD operations to demonstrate how to perform queries and update React states.",source:"@site/docs/React Native Starters/Sqlite Database.md",sourceDirName:"React Native Starters",slug:"/React Native Starters/Sqlite Database",permalink:"/docs/React Native Starters/Sqlite Database",editUrl:"https://github.com/extension-technologies/extension-technologies.github.io/docs/React Native Starters/Sqlite Database.md",version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"React Native with TypeScript",permalink:"/docs/React Native Starters/React Native With TypeScript"},next:{title:"Lixil Mobile App",permalink:"/docs/React Native Starters/Lixil Mobile App"}},d=[{value:"Topics covered in this post are:",id:"topics-covered-in-this-post-are",children:[{value:"Packages:",id:"packages",children:[]},{value:"Imports and Connection",id:"imports-and-connection",children:[]},{value:"Initialization and UI",id:"initialization-and-ui",children:[]},{value:"Operations",id:"operations",children:[]},{value:"Read",id:"read",children:[]},{value:"Create",id:"create",children:[]},{value:"Update",id:"update",children:[]},{value:"Delete",id:"delete",children:[]}]}],u={toc:d};function p(e){var t=e.components,a=(0,r.Z)(e,s);return(0,i.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"sqlite-database"},"Sqlite Database"),(0,i.kt)("p",null," In this guide, we are going to take a look at using SQLite to store and persist data locally in our React Native applications. SQLite is available on nearly all mobile devices. We have to write SQL queries to access it, however, the data returned is in javascript arrays & objects form. We are going to perform CRUD operations to demonstrate how to perform queries and update React states."),(0,i.kt)("h2",{id:"topics-covered-in-this-post-are"},"Topics covered in this post are:"),(0,i.kt)("h3",{id:"packages"},"Packages:"),(0,i.kt)("p",null,"  We are going to use the expo-sqlite package."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"   expo install expo-sqlite\n")),(0,i.kt)("p",null," For simplicity and demonstration purpose, all the code will be written in app.js file."),(0,i.kt)("h3",{id:"imports-and-connection"},"Imports and Connection"),(0,i.kt)("p",null," New we can import the package and create our database connection. We openDatabase method to create a connection with the database. If the database doesn\u2019t exists then a new one is created."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"import React from 'react';\nimport { View, Text, TouchableOpacity, ScrollView } from 'react-native';\n\nimport * as SQLite from 'expo-sqlite'\nconst db = SQLite.openDatabase('db.testDb') // returns Database object\n")),(0,i.kt)("h3",{id:"initialization-and-ui"},"Initialization and UI"),(0,i.kt)("p",null,"In this stage we will wire up the App class with essential UI, state and basic database check."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"class App extends React.Component {\n constructor(props) {\n   super(props)\n   this.state = {\n     data: null\n   }\n   // Check if the items table exists if not create it\n   db.transaction(tx => {\n     tx.executeSql(\n       'CREATE TABLE IF NOT EXISTS items (id INTEGER PRIMARY KEY AUTOINCREMENT, text TEXT, count INT)'\n     )\n   })\n   this.fetchData() // ignore it for now\n }\n render() {\n   return (\n       <View style={Style.main}>\n       <Text>Add Random Name with Counts</Text>\n       <TouchableOpacity onPress={this.newItem} style={Style.green}>\n         <Text style={Style.white}>Add New Item</Text>\n       </TouchableOpacity>\n\n       <ScrollView style={Style.widthfull}>\n       {\n           this.state.data && this.state.data.map(data =>\n           (\n               <View key={data.id} style={Style.list}>\n               <Text >{data.text} - {data.count}</Text>\n               <TouchableOpacity onPress={() => this.increment(data.id)}>\n                   <Text style={Style.boldGreen}> + </Text>\n               </TouchableOpacity>\n               <TouchableOpacity onPress={() => this.delete(data.id)}>\n                   <Text style={Style.boldRed}> DEL </Text>\n               </TouchableOpacity>\n               </View>\n           )\n       )}\n       </ScrollView>\n     </View >\n   )\n }\n}\nexport default App;\n\n")),(0,i.kt)("p",null," Ok so, we are creating a table named \u2018items\u2019 if it doesn\u2019t exists using the db connection we created above. We created a button that is supposed to add some gibberish text and a count of how many times it was pressed to the database. You can see the event handlers like addItem, increment and delete but they haven\u2019t been implemented yet, we\u2019ll implement the CRUD operations in the next section."),(0,i.kt)("h3",{id:"operations"},"Operations"),(0,i.kt)("p",null," In this section, we are going to take a look at how we can perform CRUD operations on SQLite and update React\u2019s state. We\u2019ll be using Transactions for interacting with the db using the method Database.transaction."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"Database.transaction(callback, errorCallback, successCallback)\n")),(0,i.kt)("p",null," In every transaction main callback, a Transaction object is passed that can be used to execute queries using the method Transaction.executeSql()."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"Transaction.executeSql(sqlStatementString, argumentsArray, successCallback, errorCallback)\n")),(0,i.kt)("p",null," SuccessCallback returns ResultSets, which contains rowsAffected count, insertIds in case of insert and rows of data in case of read."),(0,i.kt)("h3",{id:"read"},"Read"),(0,i.kt)("p",null," The first step is to read the data in the table every time the app is leaded. In the transaction method, we only use the main callback where a transaction object tx is passed. We use it to run a standard SQL read query. Since we don\u2019t need to pass any parameters to the query, we send null in second parameter and then we setState the ResultSet.rows._array as data. We have used the ES6 Object matching feature to extract the _array value from the ResultSet object parameter directly into _array variable."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"fetchData = () => {\n   db.transaction(tx => {\n     // sending 4 arguments in executeSql\n     tx.executeSql('SELECT * FROM items', null, // passing sql query and parameters:null\n       // success callback which sends two things Transaction object and ResultSet Object\n       (txObj, { rows: { _array } }) => this.setState({ data: _array }) \n       // failure callback which sends two things Transaction object and Error\n       (txObj, error) => console.log('Error ', error)\n       ) // end executeSQL\n   }) // end transaction\n }\n")),(0,i.kt)("h3",{id:"create"},"Create"),(0,i.kt)("p",null," We use the same pattern of transaction and executeSql as before to insert new row in the items table. To keeps thing simple, we have hardcoded the insert data for insert and state update."),(0,i.kt)("p",null," On successful insert, we use the array concat method to update the state. Concat method creates and returns a new array with the added item. It is very useful for state updates, since we don\u2019t want to alter the state object directly."),(0,i.kt)("p",null," In the setState, we also needed the Id of the new item, we accessed it from ResultSet object."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"// event handler for new item creation\nnewItem = () => {\n   db.transaction(tx => {\n     tx.executeSql('INSERT INTO items (text, count) values (?, ?)', ['gibberish', 0],\n       (txObj, resultSet) => this.setState({ data: this.state.data.concat(\n           { id: resultSet.insertId, text: 'gibberish', count: 0 }) }),\n       (txObj, error) => console.log('Error', error))\n   })\n }\n")),(0,i.kt)("h3",{id:"update"},"Update"),(0,i.kt)("p",null," We have a count property on each item and we want to increment it every time the plus button of the object is pressed. The methods we\u2019ll be using will be same as above. However, we have to be careful in updating our React states. We can\u2019t update the state directly so we\u2019ll use the map method here."),(0,i.kt)("p",null," The map method creates a new array by perform operation on each element of the original array. Thus in the map, we check to see if the Id of an item is same as the updated item. If so, create a new object and alter its count using ES 6 destructuring syntax, else return the object as it is. Thus a new list is created and we can use it to update the state safely."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"}," increment = (id) => {\n   db.transaction(tx => {\n     tx.executeSql('UPDATE items SET count = count + 1 WHERE id = ?', [id],\n       (txObj, resultSet) => {\n         if (resultSet.rowsAffected > 0) {\n           let newList = this.state.data.map(data => {\n             if (data.id === id)\n               return { ...data, count: data.count + 1 }\n             else\n               return data\n           })\n           this.setState({ data: newList })\n         }\n       })\n   })\n }\n")),(0,i.kt)("h3",{id:"delete"},"Delete"),(0,i.kt)("p",null," We also have a delete button on each item to delete it. Once the delete button is pressed, the query will be executed using the methods same as above but how do we update the React state?"),(0,i.kt)("p",null," We can use the Arrays filter method to create a new array with filtered items. In the filter method, we can specify which elements to include or exclude by returning true or false. Once this new array is created, we can update the state safely."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"delete = (id) => {\n   db.transaction(tx => {\n     tx.executeSql('DELETE FROM items WHERE id = ? ', [id],\n       (txObj, resultSet) => {\n         if (resultSet.rowsAffected > 0) {\n           let newList = this.state.data.filter(data => {\n             if (data.id === id)\n               return false\n             else\n               return true\n           })\n           this.setState({ data: newList })\n         }\n       })\n   })\n }\n")))}p.isMDXComponent=!0}}]);