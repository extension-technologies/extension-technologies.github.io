"use strict";(self.webpackChunkextention_technologies_docs=self.webpackChunkextention_technologies_docs||[]).push([[2323],{3905:function(e,n,t){t.d(n,{Zo:function(){return c},kt:function(){return m}});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),p=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},c=function(e){var n=p(e.components);return a.createElement(l.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,s=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),d=p(t),m=r,h=d["".concat(l,".").concat(m)]||d[m]||u[m]||s;return t?a.createElement(h,o(o({ref:n},c),{},{components:t})):a.createElement(h,o({ref:n},c))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var s=t.length,o=new Array(s);o[0]=d;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i.mdxType="string"==typeof e?e:r,o[1]=i;for(var p=2;p<s;p++)o[p]=t[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},6068:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return i},contentTitle:function(){return l},metadata:function(){return p},toc:function(){return c},default:function(){return d}});var a=t(7462),r=t(3366),s=(t(7294),t(3905)),o=["components"],i={sidebar_position:1},l="React Patterns",p={unversionedId:"React Native Starters/React Patterns",id:"React Native Starters/React Patterns",isDocsHomePage:!1,title:"React Patterns",description:"This document assumes a strong understanding of React. It describes the design principles of React.",source:"@site/docs/React Native Starters/React Patterns.md",sourceDirName:"React Native Starters",slug:"/React Native Starters/React Patterns",permalink:"/docs/React Native Starters/React Patterns",editUrl:"https://github.com/extension-technologies/extension-technologies.github.io/docs/React Native Starters/React Patterns.md",version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Environment Setup",permalink:"/docs/React Native Starters/Environment Setup"},next:{title:"React Native UI Components",permalink:"/docs/React Native Starters/React Native UI Components"}},c=[{value:"React Patterns With Syntax",id:"react-patterns-with-syntax",children:[{value:"Element:",id:"element",children:[]},{value:"Expressions:",id:"expressions",children:[]},{value:"Props:",id:"props",children:[]},{value:"defaultProps:",id:"defaultprops",children:[]},{value:"Destructuring props:",id:"destructuring-props",children:[]},{value:"JSX spread attributes:",id:"jsx-spread-attributes",children:[]},{value:"Merge destructured props with other values:",id:"merge-destructured-props-with-other-values",children:[]},{value:"Conditional rendering:",id:"conditional-rendering",children:[]},{value:"Children types:",id:"children-types",children:[]},{value:"Array as children",id:"array-as-children",children:[]},{value:"Function as children",id:"function-as-children",children:[]},{value:"Render prop",id:"render-prop",children:[]},{value:"Children pass-through:",id:"children-pass-through",children:[]},{value:"Proxy component:",id:"proxy-component",children:[]},{value:"Style component:",id:"style-component",children:[]},{value:"Event switch",id:"event-switch",children:[]},{value:"Layout component",id:"layout-component",children:[]},{value:"Container component:",id:"container-component",children:[]},{value:"Higher-order component",id:"higher-order-component",children:[]},{value:"State hoisting",id:"state-hoisting",children:[]},{value:"Controlled input",id:"controlled-input",children:[]}]}],u={toc:c};function d(e){var n=e.components,t=(0,r.Z)(e,o);return(0,s.kt)("wrapper",(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"react-patterns"},"React Patterns"),(0,s.kt)("p",null,"This document assumes a strong understanding of React. It describes the design principles of React."),(0,s.kt)("h2",{id:"react-patterns-with-syntax"},"React Patterns With Syntax"),(0,s.kt)("h3",{id:"element"},"Element:"),(0,s.kt)("p",null,"  Elements are anything inside angle brackets."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"<div></div>\n\n<Greeting />\n\n")),(0,s.kt)("p",null,"  All these Components return Elements."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Component:\nDefine a Component by declaring a function that returns a React Element.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"function Greeting() {\n  return <div>Hi there!</div>;\n}\n\n")),(0,s.kt)("h3",{id:"expressions"},"Expressions:"),(0,s.kt)("p",null,"  Use curly braces to embed expressions in JSX."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'function Greeting() {\n  let name = "chantastic";\n\n  return <div>Hi {name}!</div>;\n}\n')),(0,s.kt)("h3",{id:"props"},"Props:"),(0,s.kt)("p",null,"  Take props as an argument to allow outside customizations of your Component."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"function Greeting(props) {\n  return <div>Hi {props.name}!</div>;\n}\n")),(0,s.kt)("h3",{id:"defaultprops"},"defaultProps:"),(0,s.kt)("p",null,"  Specify default values for props with defaultProps."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'function Greeting(props) {\n  return <div>Hi {props.name}!</div>;\n}\nGreeting.defaultProps = {\n  name: "Guest"\n};\n')),(0,s.kt)("h3",{id:"destructuring-props"},"Destructuring props:"),(0,s.kt)("p",null,"  Destructuring assignment is a JavaScript feature.\nIt was added to the language in ES2015.\nSo it might not look familiar."),(0,s.kt)("p",null,"  Think of it like the opposite of literal assignment."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'let person = { name: "chantastic" };\nlet { name } = person;\n')),(0,s.kt)("p",null,"  Works with Arrays too."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'let things = ["one", "two"];\nlet [first, second] = things;\nlet { name } = person;\n')),(0,s.kt)("p",null,"  Destructuring assignment is used a lot in function components.\nThese component declarations below are equivalent."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"function Greeting(props) {\nreturn <div>Hi {props.name}!</div>;\n}\nfunction Greeting({ name }) {\nreturn <div>Hi {name}!</div>;\n}\n")),(0,s.kt)("p",null,"  There's a syntax for collecting remaining props into an object.\nIt's called rest parameter syntax and looks like this."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"function Greeting({ name, ...restProps }) {\nreturn <div>Hi {name}!</div>;\n}\n")),(0,s.kt)("p",null,"  Those three dots (...) take all the remaining properties and assign them to the object restProps."),(0,s.kt)("p",null,"  So, what do you do with restProps once you have it?\nKeep reading..."),(0,s.kt)("h3",{id:"jsx-spread-attributes"},"JSX spread attributes:"),(0,s.kt)("p",null,"  Spread Attributes is a feature of JSX.\nIt's a syntax for providing an object's properties as JSX attributes.\nFollowing the example from Destructuring props,"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"We can spread restProps over our <div>.\nfunction Greeting({ name, ...restProps }) {\nreturn <div {...restProps}>Hi {name}!</div>;\n}\n")),(0,s.kt)("p",null,"  This makes Greeting super flexible.\nWe can pass DOM attributes to Greeting and trust that they'll be passed through to div."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'<Greeting name="Fancy pants" className="fancy-greeting" id="user-greeting" />\n')),(0,s.kt)("p",null,"  Avoid forwarding non-DOM props to components.\nDestructuring assignment is popular because it gives you a way to separate component-specific props from DOM/platform-specific attributes."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"function Greeting({ name, ...platformProps }) {\nreturn <div {...platformProps}>Hi {name}!</div>;\n}\n")),(0,s.kt)("h3",{id:"merge-destructured-props-with-other-values"},"Merge destructured props with other values:"),(0,s.kt)("p",null,"  Components are abstractions.\nGood abstractions allow for extension."),(0,s.kt)("p",null,"  Consider this component that uses a class attribute for style a button."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'function MyButton(props) {\nreturn <button className="btn" {...props} />;\n}\n')),(0,s.kt)("p",null,"  This works great until we try to extend it with another class."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'<MyButton className="delete-btn">Delete...</MyButton>\n')),(0,s.kt)("p",null,"  In this case, delete-btn replaces btn."),(0,s.kt)("p",null,"  Order matters for JSX spread attributes.\nThe props.className being spread is overriding the className in our component."),(0,s.kt)("p",null,"  We can change the order but now the className will never be anything but btn."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'function MyButton(props) {\nreturn <button {...props} className="btn" />;\n}\nWe need to use destructuring assignment to get the incoming className and merge with the base className.\nWe can do this simply by adding all values to an array and joining them with a space.\n```bash\nfunction MyButton({ className, ...props }) {\nlet classNames = ["btn", className].join(" ");\nreturn <button className={classNames} {...props} />;\n}\n')),(0,s.kt)("p",null,"  To guard from undefined showing up as a className, you could update your logic to filter out falsy values:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'function MyButton({ className, ...props }) {\nlet classNames = ["btn", className].filter(Boolean).join(" ").trim();\nreturn <button className={classNames} {...props} />;\n}\n')),(0,s.kt)("p",null,"  Bear in mind though that if an empty object is passed it'll be included in the class as well, resulting in: btn ","[object Object]","."),(0,s.kt)("p",null,"  The better approach is to make use of available packages, like classnames or clsx, that could be used to join classnames, relieving you from having to deal with it manually."),(0,s.kt)("h3",{id:"conditional-rendering"},"Conditional rendering:"),(0,s.kt)("p",null,"  You can't use if/else statements inside a component declarations.\nSo conditional (ternary) operator and short-circuit evaluation are your friends."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"if:\n{\ncondition && <span>Rendered when `truthy`</span>;\n}\nunless\n{\ncondition || <span>Rendered when `falsy`</span>;\n}\nif-else\n{\ncondition ? (\n  <span>Rendered when `truthy`</span>\n) : (\n  <span>Rendered when `falsy`</span>\n);\n}\n")),(0,s.kt)("h3",{id:"children-types"},"Children types:"),(0,s.kt)("p",null,"  React can render children from most types.\nIn most cases it's either an array or a string."),(0,s.kt)("p",null,"  String"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"<div>Hello World!</div>\n")),(0,s.kt)("p",null,"  Array"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'<div>{["Hello ", <span>World</span>, "!"]}</div>\n')),(0,s.kt)("h3",{id:"array-as-children"},"Array as children"),(0,s.kt)("p",null,"  Providing an array as children is a very common.\nIt's how lists are drawn in React."),(0,s.kt)("p",null,"  We use map() to create an array of React Elements for every value in the array."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'<ul>\n{["first", "second"].map(item => (\n  <li>{item}</li>\n))}\n</ul>\n')),(0,s.kt)("p",null,"  That's equivalent to providing a literal array."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"<ul>{[<li>first</li>, <li>second</li>]}</ul>\n")),(0,s.kt)("p",null,"  This pattern can be combined with destructuring, JSX Spread Attributes, and other components, for some serious terseness."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"<ul>\n{arrayOfMessageObjects.map(({ id, ...message }) => (\n  <Message key={id} {...message} />\n))}\n</ul>\n")),(0,s.kt)("h3",{id:"function-as-children"},"Function as children"),(0,s.kt)("p",null,"  React components don't support functions as children. However, render props is a pattern for creating components that take functions as children."),(0,s.kt)("h3",{id:"render-prop"},"Render prop"),(0,s.kt)("p",null,"  Here's a component that uses a render callback.\nIt's not useful, but it's an easy illustration to start with."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"const Width = ({ children }) => children(500);\n")),(0,s.kt)("p",null,"  The component calls children as a function, with some number of arguments. Here, it's the number 500."),(0,s.kt)("p",null,"  To use this component, we give it a function as children."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"<Width>{width => <div>window is {width}</div>}</Width>\n")),(0,s.kt)("p",null,"  We get this output."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"<div>window is 500</div>\n")),(0,s.kt)("p",null,"  With this setup, we can use this width to make rendering decisions."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"<Width>\n{width => (width > 600 ? <div>min-width requirement met!</div> : null)}\n</Width>\n")),(0,s.kt)("p",null,"  If we plan to use this condition a lot, we can define another components to encapsulate the reused logic."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"const MinWidth = ({ width: minWidth, children }) => (\n<Width>{width => (width > minWidth ? children : null)}</Width>\n);\n")),(0,s.kt)("p",null,"  Obviously a static Width component isn't useful but one that watches the browser window is. Here's a sample implementation."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'class WindowWidth extends React.Component {\nconstructor() {\n  super();\n  this.state = { width: 0 };\n}\ncomponentDidMount() {\n  this.setState({ width: window.innerWidth }, () =>\n    window.addEventListener("resize", ({ target }) =>\n      this.setState({ width: target.innerWidth })\n    )\n  );\n}\nrender() {\n  return this.props.children(this.state.width);\n}\n}\n')),(0,s.kt)("p",null,"  Many developers favor Higher Order Components for this type of functionality. It's a matter of preference."),(0,s.kt)("h3",{id:"children-pass-through"},"Children pass-through:"),(0,s.kt)("p",null,"  You might create a component designed to apply context and render its children."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'class SomeContextProvider extends React.Component {\ngetChildContext() {\n  return { some: "context" };\n}\nrender() {\n  // how best do we return `children`?\n}\n}\n')),(0,s.kt)("p",null,"  You're faced with a decision. Wrap children in an extraneous ",(0,s.kt)("div",null)," or return children directly. The first options gives you extra markup (which can break some stylesheets). The second will result in unhelpful errors."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"// option 1: extra div\nreturn <div>{children}</div>;\n\n// option 2: unhelpful errors\nreturn children;\n")),(0,s.kt)("p",null,"  It's best to treat children as an opaque data type. React provides React.Children for dealing with children appropriately."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"return React.Children.only(this.props.children);\n")),(0,s.kt)("h3",{id:"proxy-component"},"Proxy component:"),(0,s.kt)("p",null,' Buttons are everywhere in web apps. And every one of them must have the type attribute set to "button".'),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'<button type="button">\n')),(0,s.kt)("p",null,"Writing this attribute hundreds of times is error prone. We can write a higher level component to proxy props to a lower-level button component."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'const Button = props =>\n <button type="button" {...props}>\n')),(0,s.kt)("p",null," We can use Button in place of button and ensure that the type attribute is consistently applied everywhere."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'<Button />\n// <button type="button"><button>\n\n<Button className="CTA">Send Money</Button>\n// <button type="button" class="CTA">Send Money</button>\n')),(0,s.kt)("h3",{id:"style-component"},"Style component:"),(0,s.kt)("p",null," This is a Proxy component applied to the practices of style."),(0,s.kt)("p",null,' Say we have a button. It uses classes to be styled as a "primary" button.'),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'<button type="button" className="btn btn-primary">\n')),(0,s.kt)("p",null," We can generate this output using a couple single-purpose components."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'import classnames from "classnames";\n\nconst PrimaryBtn = props => <Btn {...props} primary />;\n\nconst Btn = ({ className, primary, ...props }) => (\n <button\n   type="button"\n   className={classnames("btn", primary && "btn-primary", className)}\n   {...props}\n />\n);\n')),(0,s.kt)("p",null," It can help to visualize this."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'PrimaryBtn()\n \u21b3 Btn({primary: true})\n   \u21b3 Button({className: "btn btn-primary"}, type: "button"})\n     \u21b3 \'<button type="button" class="btn btn-primary"></button>\'\n')),(0,s.kt)("p",null," Using these components, all of these result in the same output."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'<PrimaryBtn />\n<Btn primary />\n<button type="button" className="btn btn-primary" />\n')),(0,s.kt)("p",null," This can be a huge boon to style maintenance. It isolates all concerns of style to a single component."),(0,s.kt)("h3",{id:"event-switch"},"Event switch"),(0,s.kt)("p",null," When writing event handlers it's common to adopt the handle{eventName} naming convention."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"handleClick(e) { /* do something */ }\n")),(0,s.kt)("p",null," For components that handle several event types, these function names can be repetitive. The names themselves might not provide much value, as they simply proxy to other actions/functions."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'handleClick() { require("./actions/doStuff")(/* action stuff */) }\nhandleMouseEnter() { this.setState({ hovered: true }) }\nhandleMouseLeave() { this.setState({ hovered: false }) }\n')),(0,s.kt)("p",null," Consider writing a single event handler for your component and switching on event.type."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'handleEvent({type}) {\n switch(type) {\n   case "click":\n     return require("./actions/doStuff")(/* action dates */)\n   case "mouseenter":\n     return this.setState({ hovered: true })\n   case "mouseleave":\n     return this.setState({ hovered: false })\n   default:\n     return console.warn(`No case for event type "${type}"`)\n }\n}\n')),(0,s.kt)("p",null," Alternatively, for simple components, you can call imported actions/functions directly from components, using arrow functions."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'<div onClick={() => someImportedAction({ action: "DO_STUFF" })}\n')),(0,s.kt)("p",null," Don't fret about performance optimizations until you have problems. Seriously don't."),(0,s.kt)("h3",{id:"layout-component"},"Layout component"),(0,s.kt)("p",null," Layout components result in some form of static DOM element. It might not need to update frequently, if ever."),(0,s.kt)("p",null," Consider a component that renders two children side-by-side."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"<HorizontalSplit\n startSide={<SomeSmartComponent />}\n endSide={<AnotherSmartComponent />}\n/>\n")),(0,s.kt)("p",null," We can aggressively optimize this component."),(0,s.kt)("p",null," While HorizontalSplit will be parent to both components, it will never be their owner. We can tell it to update never, without interrupting the lifecycle of the components inside."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"class HorizontalSplit extends React.Component {\n shouldComponentUpdate() {\n   return false;\n }\n render() {\n   return (\n     <FlexContainer>\n       <div>{this.props.startSide}</div>\n       <div>{this.props.endSide}</div>\n     </FlexContainer>\n   );\n }\n }\n")),(0,s.kt)("h3",{id:"container-component"},"Container component:"),(0,s.kt)("p",null,' "A container does data fetching and then renders its corresponding sub-component. That\u2019s it."\u2014Jason Bonta\nGiven this reusable CommentList component.'),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"const CommentList = ({ comments }) => (\n <ul>\n   {comments.map(comment => (\n     <li>\n       {comment.body}-{comment.author}\n     </li>\n   ))}\n </ul>\n );\n")),(0,s.kt)("p",null,"  We can create a new component responsible for fetching data and rendering the CommentList function component."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"class CommentListContainer extends React.Component {\nconstructor() {\n  super()\n  this.state = { comments: [] }\n}\ncomponentDidMount() {\n  $.ajax({\n    url: \"/my-comments.json\",\n    dataType: 'json',\n    success: comments =>\n      this.setState({comments: comments});\n  })\n}\nrender() {\n  return <CommentList comments={this.state.comments} />\n}\n}\n")),(0,s.kt)("p",null,"  We can write different containers for different application contexts."),(0,s.kt)("h3",{id:"higher-order-component"},"Higher-order component"),(0,s.kt)("p",null,"  A higher-order function is a function that takes and/or returns a function. It's not more complicated than that. So, what's a higher-order component?"),(0,s.kt)("p",null,"  If you're already using container components, these are just generic containers, wrapped up in a function."),(0,s.kt)("p",null,"  Let's start with our Greeting component."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"const Greeting = ({ name }) => {\nif (!name) {\n  return <div>Connecting...</div>;\n}\nreturn <div>Hi {name}!</div>;\n};\n")),(0,s.kt)("p",null,"  If it gets props.name, it's gonna render that data. Otherwise it'll say that it's \"Connecting...\". Now for the the higher-order bit."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'const Connect = ComposedComponent =>\nclass extends React.Component {\n  constructor() {\n    super();\n    this.state = { name: "" };\n  }\n\n componentDidMount() {\n    // this would fetch or connect to a store\n    this.setState({ name: "Michael" });\n  }\n\n  render() {\n    return <ComposedComponent {...this.props} name={this.state.name} />;\n  }\n};\n')),(0,s.kt)("p",null,"  This is just a function that returns component that renders the component we passed as an argument."),(0,s.kt)("p",null,"  Last step, we need to wrap our Greeting component in Connect."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"const ConnectedMyComponent = Connect(Greeting);\n")),(0,s.kt)("p",null,"  This is a powerful pattern for providing fetching and providing data to any number of function components."),(0,s.kt)("h3",{id:"state-hoisting"},"State hoisting"),(0,s.kt)("p",null,"  function-component don't hold state (as the name implies)."),(0,s.kt)("p",null,"  Events are changes in state. Their data needs to be passed to stateful container components parents."),(0,s.kt)("p",null,'  This is called "state hoisting". It\'s accomplished by passing a callback from a container component to a child component.'),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"class NameContainer extends React.Component {\nrender() {\n  return <Name onChange={newName => alert(newName)} />;\n}\n}\n\nconst Name = ({ onChange }) => (\n<input onChange={e => onChange(e.target.value)} />\n);\n")),(0,s.kt)("p",null,"  Name receives an onChange callback from NameContainer and calls on events."),(0,s.kt)("p",null,"  The alert above makes for a terse demo but it's not changing state. Let's change the internal state of NameContainer."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'class NameContainer extends React.Component {\nconstructor() {\n  super();\n  this.state = { name: "" };\n}\n\nrender() {\n  return <Name onChange={newName => this.setState({ name: newName })} />;\n}\n}\n')),(0,s.kt)("p",null,"  The state is hoisted to the container, by the provided callback, where it's used to update local state. This sets a nice clear boundary and maximizes the re-usability of function component."),(0,s.kt)("p",null,"  This pattern isn't limited to function components. Because function components don't have lifecycle events, you'll use this pattern with component classes as well."),(0,s.kt)("p",null,"  Controlled input is an important pattern to know for use with state hoisting"),(0,s.kt)("p",null,"  (It's best to process the event object on the stateful component)"),(0,s.kt)("h3",{id:"controlled-input"},"Controlled input"),(0,s.kt)("p",null,"  It's hard to talk about controlled inputs in the abstract. Let's start with an uncontrolled (normal) input and go from there."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'<input type="text" /> \n')),(0,s.kt)("p",null,"  When you fiddle with this input in the browser, you see your changes. This is normal."),(0,s.kt)("p",null,"  A controlled input disallows the DOM mutations that make this possible. You set the value of the input in component-land and it doesn't change in DOM-land."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'<input type="text" value="This won\'t change. Try it." />\n')),(0,s.kt)("p",null,"  Obviously static inputs aren't very useful to your users. So, we derive a value from state."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'class ControlledNameInput extends React.Component {\nconstructor() {\n  super();\n  this.state = { name: "" };\n}\n\nrender() {\n  return <input type="text" value={this.state.name} />;\n}\n}\nThen, changing the input is a matter of changing component state.\n\nreturn (\n<input\n  value={this.state.name}\n  onChange={e => this.setState({ name: e.target.value })}\n/>\n);\n')),(0,s.kt)("p",null,"This is a controlled input. It only updates the DOM when state has changed in our component. This is invaluable when creating consistent UIs."))}d.isMDXComponent=!0}}]);